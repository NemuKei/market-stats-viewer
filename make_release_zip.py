from __future__ import annotations

import argparse
import fnmatch
import subprocess
from datetime import datetime, timedelta, timezone
from pathlib import Path
from zipfile import ZIP_DEFLATED, ZipFile

JST = timezone(timedelta(hours=9))

# --- project-specific includes (market-stats-viewer) ---
# NOTE:
# - This script uses fnmatch for include filtering.
# - Therefore patterns like "scripts/**/*" do NOT match "scripts/update_data.py".
#   Use "scripts/**" (or "scripts/*.py") instead.
INCLUDE_GLOBS = [
    # Entry points / governance
    "AGENTS.md",
    # App / scripts
    "README.md",
    "app.py",
    "requirements.txt",
    "make_release_zip.py",
    ".github/**",
    "scripts/**",
    # Docs (spec/handovers/logs/templates)
    "docs/**",
    # Misc
    "LICENSE*",
    ".gitignore",
    ".gitattributes",
    ".editorconfig",
    "pyproject.toml",
]

# Added only when --with-data (often generated by Actions)
DATA_GLOBS = [
    "data/meta.json",
    "data/market_stats.sqlite",
]

EXCLUDE_GLOBS = [
    ".git/**",
    ".venv/**",
    "venv/**",
    "**/.venv/**",
    "__pycache__/**",
    ".pytest_cache/**",
    ".mypy_cache/**",
    ".ruff_cache/**",
    "node_modules/**",
    "dist/**",
    "build/**",
    "tmp/**",
    "*.pyc",
    "*.pyo",
    "*.pyd",
    ".DS_Store",
    "Thumbs.db",
    ".idea/**",
    ".vscode/**",
    "*.zip",
    "*.7z",
    "packages/**",
]

DANGEROUS_HINTS = [
    ".env",
    "secrets",
    "secret",
    "apikey",
    "api_key",
    "token",
    "password",
    "credentials",
    "private_key",
    ".p12",
    ".pem",
    ".key",
]


def safe_slug(s: str, max_len: int = 80) -> str:
    out = (
        s.strip()
        .replace(" ", "-")
        .replace("/", "-")
        .replace("\\", "-")
        .replace(":", "-")
        .replace("*", "-")
        .replace("?", "-")
        .replace('"', "-")
        .replace("<", "-")
        .replace(">", "-")
        .replace("|", "-")
    )
    while "--" in out:
        out = out.replace("--", "-")
    if not out:
        out = "unknown"
    return out[:max_len] if len(out) > max_len else out


def run_git(cmd: list[str], cwd: Path) -> str:
    try:
        return subprocess.check_output(cmd, cwd=str(cwd), text=True).strip()
    except Exception:
        return ""


def is_excluded(rel_posix: str) -> bool:
    return any(fnmatch.fnmatch(rel_posix, pat) for pat in EXCLUDE_GLOBS)


def matches_any(rel_posix: str, patterns: list[str]) -> bool:
    return any(fnmatch.fnmatch(rel_posix, pat) for pat in patterns)


def looks_dangerous(rel_posix: str) -> bool:
    low = rel_posix.lower()
    return any(h in low for h in DANGEROUS_HINTS)


def collect_files(repo_root: Path, use_git_only: bool, with_data: bool) -> list[Path]:
    patterns = list(INCLUDE_GLOBS)
    if with_data:
        patterns += DATA_GLOBS

    if use_git_only:
        out = run_git(["git", "ls-files"], repo_root)
        tracked = [repo_root / p for p in out.splitlines() if p.strip()]
        candidates = [p for p in tracked if p.is_file()]
    else:
        candidates = [p for p in repo_root.rglob("*") if p.is_file()]

    picked: list[Path] = []
    for p in candidates:
        rel = p.relative_to(repo_root).as_posix()

        if is_excluded(rel):
            continue
        if not matches_any(rel, patterns):
            continue
        if looks_dangerous(rel):
            continue

        picked.append(p)

    return sorted(set(picked))


def write_manifest(repo_root: Path, files: list[Path], meta: dict) -> tuple[str, str]:
    version = meta["version"]
    version_txt = f"{version}\n"
    lines = [f"version: {version}"]
    for k in ["repo", "branch", "commit", "created_at_jst", "with_data", "git_only"]:
        if k in meta:
            lines.append(f"{k}: {meta[k]}")
    lines.append("")
    lines.append("files:")
    for p in files:
        lines.append(f"- {p.relative_to(repo_root).as_posix()}")
    manifest_txt = "\n".join(lines) + "\n"
    return version_txt, manifest_txt


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--tag", default="market-stats-viewer")
    ap.add_argument("--outdir", default="packages")
    ap.add_argument("--with-data", action="store_true")
    ap.add_argument("--no-git-only", action="store_true")
    args = ap.parse_args()

    repo_root = Path(__file__).resolve().parent
    outdir = repo_root / args.outdir
    outdir.mkdir(parents=True, exist_ok=True)

    git_only = not args.no_git_only

    repo = run_git(["git", "config", "--get", "remote.origin.url"], repo_root)
    branch = run_git(["git", "rev-parse", "--abbrev-ref", "HEAD"], repo_root)
    commit = run_git(["git", "rev-parse", "--short", "HEAD"], repo_root)

    now = datetime.now(JST)
    stamp = now.strftime("%Y%m%d_%H%M")
    meta = {
        "repo": repo or "unknown",
        "branch": branch or "unknown",
        "commit": commit or "unknown",
        "created_at_jst": now.strftime("%Y-%m-%d %H:%M:%S %z"),
        "with_data": bool(args.with_data),
        "git_only": bool(git_only),
    }

    version = f"{stamp}_{safe_slug(branch or 'main')}_{safe_slug(commit or 'nogit')}"
    meta["version"] = version

    files = collect_files(repo_root, use_git_only=git_only, with_data=args.with_data)
    version_txt, manifest_txt = write_manifest(repo_root, files, meta)

    zip_name = f"{safe_slug(args.tag)}_{version}_full.zip"
    zip_path = outdir / zip_name

    with ZipFile(zip_path, "w", compression=ZIP_DEFLATED) as z:
        z.writestr("VERSION.txt", version_txt)
        z.writestr("MANIFEST.txt", manifest_txt)
        for p in files:
            rel = p.relative_to(repo_root).as_posix()
            z.write(p, arcname=rel)

    print(f"OK: wrote {zip_path}")
    print(
        f"     git_only={git_only} with_data={bool(args.with_data)} files={len(files)}"
    )


if __name__ == "__main__":
    main()
